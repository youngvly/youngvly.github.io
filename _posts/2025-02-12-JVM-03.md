---
title: "JVM 밑바닥까지 파헤치기 : 3 가비지 컬렉터와 메모리 할당 전략"
date: 2025-02-12 17:00:00 +0900
categories: study, jvm, java
tags: study, java, jvm
---

# 3. 가비지 컬렉터와 메모리 할당 전략 
- 이 책에서 '메모리 할당과 회수'할때의 메모리는 힙메모리
## 3.2 대상이 죽었는가?
### 3.2.1 참조 카운팅 알고리즘
- 직접 가비지 컬렉션
- 객체를 가리키는 참조 카운터를 두는 방식, 일반적으로 사용됨 python, rust,,
- JVM에서는 사용하지않음
- 순환참조인 경우 참조카운팅이 1과 1이므로, 두 객체 모두 사용되지 않음에도 GC가 걷어갈 수 없음.

### 3.2.2 도달 가능성 분석 알고리즘
- 간접 가비지 컬렉션
- 어떤 객체와 GC 루트 사이를 이어주는 참조 체인이 없다면 회수대상. 

### 3.2.3 다시 참조이야기
- 강한 참조 : 프로그램 코드에서 참조를 할당하는것, 관계가 남아있다면 절대 회수하지 않는다.
    ```java
    Object obj = new Object()
    ```
- 부드러운 참조 : 메모리가 부족하여 오버플로우가 나기 직전에 두번째 회수를 위한 회수목록에 추가된다.
    - `SoftReference` 클래스
- 약한 참조 : 다음 GC까지만 살아있다. 메모리가 넉넉하더라도 회수된다.
    - `WeakReference` 클래스
- 파이널 참조 : `finalize()` 를 구현한 객체, 모든 참조가 사라지면 fianlize 메서드가 호출된다.
    - JDK9부터 사라진 스펙, 몰라도 됨.
    - finalize 에서 자신을 참조하면, GC에서 1회 면제될 수 있다. 꼼수이기도하고, 불확실해서 제거되었다고함.
- 유령 참조 : 객체 수명에 아무런 영향을 주지않는다. 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위함.
    - `PhantomReference` 클래스

### 3.2.5 메서드 영역 회수하기
- JDK12 이후의 ZGC 부터 클래스 언로딩을 지원한다.
- 메서드 영역에서 GC가 회수하는것은 상수와 클래스.
- GC 효율이 heap에 비해 떨어지는편
- 클래스 회수
    - `Xnoclassgc` 옵션 지원
    - 리플렉션, 동적 proxy, CGLib 같은 바이트코드 프레임워크를 많이 사용하는 경우, JSP를 동적으로 생성하고 클래스 로더를 자주 사용자화하는 OSGi 환경 등에서는 일반적으로 타입 언로딩을 지원해야한다.
    
## 3.3 가비지 컬렉션 알고리즘
### 3.3.1 세대단위 컬렉션 이론
- GC에서 살아남은 횟수로 자바 힙 내에서 다른 영역에 할당하는 방식
- 실제 상황에서 얻은 경험 법칙을 구현한 것이다.
    1. 약한 세대 가설 : 대다수의 객체는 일찍 죽는다
    2. 강산 세대 가설 : GC 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
    3. 세대간 참조 가설 : 세대간 참조의 갯수는 같은 세대 안에서의 참조보다 훨씬 적다.
- 신세대 young : 생명주기가 짧은 객체, 한번도 GC에서 살아남지않은 객체,
- 구세대 old : GC에서 신세대 객체가 다수 죽고, 소수가 구세대로 승격된다.
- 두 세대간에 참조관계를 가지는 객체가 있다면, young -> old 로 승격한다.
    - 세대간 참조관계를 알기위해 old를 minor GC마다 볼수없으므로, old를 기억집합이라는 조각단위로 나누어 참조가 있는지 별도로 기록하고, GC때에는 해당 조각만 본다.

### GC 방식
1. 부분 GC
    - minor GC (young GC) : 신세대만 대상
    - major GC (old GC) : 구세대만 대상. (CMS 컬렉터만 구세대를 따로 회수한다.)
    - 혼합 GC : 신세대 전체와 구세대 일부 대상. (G1 컬렉터만 이렇게 동작.)
2. Full GC  : 자바 힙 + 메서드 영역

### 3.3.2 mark-sweep 알고리즘 (기본)
- 회수대상을 mark 하고, sweep 단계에서 회수
- 단점
    1. 객체가 많아질수록 표시하고 쓸어담는 작업의 효율이 떨어진다.
    2. sweep 이후 불연속적인 메모리 파편화가 심하다.

### 3.3.3 mark-copy 알고리즘
- mark-sweep 단점 2를 보완
- 가용 메모리를 같은 크기의 두 블록으로 나누어, 한쪽블록이 꽉차면 살아남는 객체를 copy, 기존 블록을 청소한다.
- 단점
    1. 가용 메모리가 절반이 된다.
    2. 객체 생존률이 높아질수록 복사할게 많아져서 효율이 나쁘다.
- 대다수가 살아남는 old 영역에서는 적합하지 않음.
- 아펠스타일 : young 영역을 나누는 방식.
    - 에덴 (80%) : 신규 객체 영역
    - 생존자 공간 1(10%) : 한번 GC 후 살아남은 영역 (예비 old?)
    - 생존자 공간 2(10%) : <에덴 + 생존자공간1> 이 한번에 GC되어 살아남은 객체를 이곳에 할당. GC 이후에는 <에덴 + 생존자공간2> 가 사용된다.
    - 생존자공간 10%가 GC 이후 수용하지 못하는 경우, old 에 바로 추가된다.
- stop-the-world가 발생하는 mark-compact 대신, 지연시간에 중점을 둔 다면 mark-copy 가 유리. (CMS collector)

### 3.3.4 mark-compact 알고리즘
- mark-copy의 단점 2를 보완
- compact 단계에서 생존객체를 한쪽 끝으로 모으고, 그외 메모리 청소.
- 참조를 바꾸는것은 stop-the-world 를 유발.
- 구세대에서 생존객체가 많을때에는 참조 이동이 부담될것.
- 프로그램 처리량관점에서는 메모리 할당에 유리한 mark-compact가 유리. (parellel old collector)

## 3.4 핫스팟 알고리즘 상세 구현
### 3.4.1 루트 노드 열거
- 도달 가능성 분석 알고리즘에서 GC root 집합으로부터 참조 체인을 찾는 작업.
- 루트 노드들의 참조 관계가 변하지 않아야하므로, stop-the-world는 불가피.
- 거의 정지하지않는 CMS,G1,ZGC도 이때는 일시정지를 피할 수 없다.
- 가상머신이 객체 참조가 저장된 위치를 직접 알아내는 방법도 있다.
    - Hotspot 은 OopMap 데이터 구조를 사용하여, JIT 컴파일과정에서 네이티브 코드상에 스택의 위치, 어느 레지스터 데이터가 참조인지 기록한다. 이 정보로 루트 직접 얻기 가능.

### 3.4.2 안전 지점
- HotspotVM이 참조관계나 OopMap 내용을 변경하는 명령어에도 OopMap를 생성하면 공간비용이 드므로, Safe point 라는 위치에만 기록한다.
- GC는 안전지점이 도달할때까지는 stop-the-world하지않는다.
- (자발적 멈춤) 일반적으로 중단 flag bit를 polling하여 확인.
- 안전 지점의 위치는 메서드 호출,순환문,예외처리 같은 명령어 흐름 다중화 하는 명령어에서 생성한다.
> 안전 지점에만 OopMap을 저장한다는건줄 알았는데, 코드 3-4를 보아 안전지점은 참조가 변경되지않는 스레드 중단 지점인듯하고, 메서드마다 다 저장되는것같은데???

### 3.4.3 안전 지역
- 일정 코드 영역에서는 참조관계가 변하지 않음을 보장하는 영역이다.
- sleep 중이거나, 스레드가 block된 실행중이지않은 프로그램인 경우 안전지점까지 수행하는걸 기다릴 수 없기때문에 생성된 개념.
- 안전 지역안에서는 GC를 언제든 시작해도 무방하다.
- 스레드가 안전지역을 벗어날때 stop-the-world 중이라면, 중지 해제 신호를 기다려야한다.

### 3.4.4 기억집합과 카드 테이블
- 비회수 영역에서 회수 영역을 가리키는 포인터들을 기록하는 추상 데이터 구조.
- 정밀도
    - 워드 정밀도 : 레코드 하나가 메모리 워드(32/64bit) 하나에 매핑.
    - 객체 정밀도 : 레코드 하나가 객체 하나에 매핑. (비회수 영역 객체에 마킹되는개념?)
    - 카드 정밀도 : 레코드 하나가 메모리 블록 하나에 매핑.
- 카드 테이블 : 카드 정밀도로 구현된 기억집합, 가장 널리 쓰임.
    - Hotspot에서는 byte배열로 구현한다. 카드테이블에서의 1개의 비트가 2^9 byte 크기의 메모리 블록(카드페이지)의 참조 여부 플래그를 가지고있다.
    ```java
    CARD_TABLE[A address >> 9] = 1; // A 객체가 위치한 메모리 블록에 있는 객체들 중 회수대상을 참조하는 것이 있다.
    ```

### 3.4.5 쓰기 장벽
- 카드테이블 갱신 시점은 참조 타입 필드에 값이 대입되는 순간이다.
- JIT 컴파일 후의 캐싱된 코드는 기계어 명령어이므로, JVM이 명령어를 개입하기 어렵다.
- HotSpot에서는 참조타입 필드 대입 후에 (사후 쓰기 장벽) 카드테이블 갱신 메서드를 호출하는 코드를 추가 후 컴파일한다.
- 거짓 공유 : 동시성 문제, 동일 CPU 프로세서 캐시라인에 해당하는 카드테이블을 동시에 수정할때 동기화문제가 발생할수있는데, 캐시라인만 같을뿐 실제로는 공유하고있지 않지만 동시성영향을 줄 수 있기때문에 거짓 공유라고 함.

### 3.4.6 동시 접근 가능성 분석
- 루트노드 열거 단계에서 GC 루트는 전체 자바힙에 존재하는 객체대비 매우 적은양이며, OopMap같은 최적화 덕에 루트노드열거시 중단 시간은 매우 짧고 일정하다.
- GC루트에서 객체 그래프를 탐색하는 과정은 객체 수에 비례한다.
- 객체 그래프 탐색시에 중지가 발생해야하는 이유 : 살아있는 객체가 죽었다고 표시되어 회수될 수 있다.
- 중단없이 살아있는 객체가 청소되는 문제 해결방법
    1. 증분 업데이트 : 탐색이 끝난 노드에서 새로운 참조가 생기면 별도 기록
    2. 시작 단계 스냅숏 : 노드 탐색이 시작하는 순간을 기준으로 스캔하고, 탐색중에 참조가 제거되면 별도 기록.
- 핫스팟 VM은 1,2를 모두 사용.
> 중단없이 참조 변경 사항을 계속 기록하면 이것도 끝이 없지 않을까 ?.?

## 3.5 클래식 가비지 컬렉터
### 3.5.1 serial collector
- 신/구세대 지원
- 단일스레드로 동작하는 GC
- 회수가 완료될때까지 stop-the-world
- 신세대 : mark-copy 
- 구세대 : mark-compact
- 장점
    - 다른 단일 스레드 알고리즘보다 간단하고 효율적
    - 메모리 사용량이 가장 적다
    - 코어수가 적은 환경이라면 스레드 상호작용에 의한 오버헤드가 없다.
- -XX:+UseSerialGC

### 3.5.2 ParNew collector
- 신/구세대 지원
- 시리얼 컬렉터를 병렬화 한 버전
- 구세대 CMS + 신세대 ParNew 조합으로 인기가 높았다. (시리얼 컬렉터도 조합가능)
- G1GC가 힙 전체를 대상으로 하는 컬렉터로 등장하면서 CMS에 통합되었다.
- 프로세서별
    - 단일 코어 프로세서에서는 시리얼 컬렉터보다 성능이 떨어진다.
    - 가상 듀얼 코어 환경에서도 시리얼 컬렉터보다 낫다고 보장할 수 없다.
        - 코어수가 늘어나면 시스템 자원을 효율적으로 사용할 가능성이 커진다. (GC 스레드수는 기본적으로 코어수와 동일)

#### 병렬과 동시 개념의 컬렉터
- 병렬 parallel : GC 스레드 다수가 동시에 수행
- 동시 concurrent : GC 스레드와 사용자 스레드가 동시에 일을 진행

### 3.5.3 PS (parellel scavenge) collector
- 신세대용
- 처리량을 제어하는것이 목표이다.
    - CMS 는 사용자 스레드의 일시정지 시간을 최소로 줄이는것이 목표였음.
    - 처리량 : 사용자 코드 실행시간 비율 = (사용자 코드 실행시간) / (사용자 코드 실행 시간 + GC 실행 시간)
        - 100분중 GC에 1분이 소요되었다면 처리량은 99%
    - 응답속도를 보장해야하는 QoS 프로그램 등에서 사용하기 좋음.
- GC 정지시간의 최댓값 `-XX:MaxGCPauseMillis`  처리량 지정 `-XX:GCTimeRatio=(Int)`
    - 정지시간을 줄여버리면, 신세대의 크기가 작게 할당되고, 더 자주 회수해야해서 처리량이 낮아진다
    - 적응형 조율 전략 : 처리량을 조정하면, VM이 성능 모니터링 정보를 수집하여 최적의 정지시간과 신세대의 크기 등을 자동으로 조절해준다.
        - 세밀한 수동 최적화가 어렵다면 PS컬렉터가 괜찮은 선택
    - `-XX:GCTimeRatio=99` : 애플리케이션이 GC보다 99배이상의 시간을 써야한다 = GC가 전체 실행시간의 1%를 초과하지 않아야한다.

### 3.5.4 serial old collector
- 시리얼 컬레겉의 구세대용 버전
- ~JDK6까지 신세대 PS + 구세대 serial old 조합으로 사용됨. 

### 3.5.5 parallel old collector
- 처리량이 중요하거나 프로세서 자원이 부족한 상황 : JDK7~ 신세대 PS + 구세대 Parallel old 
- old 메모리 용량이 크고, 하드웨어가 상대적으로 우수한 상황 : 신세대 Parnew + 구세대 CMS

### 3.5.6 CMS collector
- mark and sweep 을 사용자 스레드와 동시에 수행한다.
- 이 컬렉터의 목적은 일시정지 시간을 최소로 줄이는것.
    - 웹서버에서 사용시 사용자 경험을 개선시킬 수 있다.
- 과정
    1. 최초 표시 (mark) : 아주 빠르게 정지, GC 루트 마크
    2. 동시 표시 (mark) : 사용자 스레드와 동시 동작. 객체 탐색
    3. 재표시 (mark) : 1보다는 길게 정지,  (3.4.6 증분업데이트 참고)
    4. 동시 슬기 (sweep) : 사용자 스레드와 동시 동작. 
- 단점
    1. 동시수행이므로, 프로세서 자원에 매우 민감하다. 
        - 사용자 스레드를 멈추지는 않더라도, 애플리케이션을 느리게하고 전체 처리량을 떨어뜨린다.
    2. 부유쓰레기를 처리하지못해 동시모드 실패 유발 가능성.
        - 부유 쓰레기 : 재표시에서 놓친 객체는 다음 GC에서 회수된다.
        - 동시 실행되므로, CMS는 구세대가 가득 찰때까지 여유롭게 기다릴 수없다. 
        - 메모리 문턱값을 조정할 수 있는데, 그럼에도 메모리가 다 차버리면 동시모드 실패. 임시로 serial old collector를 실행하며 전체 중지된다.
    3. mark-sweep 이므로 메모리 파편화가 심하면 전체 GC시 참조객체 이동이 필요하다. 이때 중지시간이 길어진다.
- JDK9부터 폐기대상, JDK14에서 제거됨.

### 3.5.7 G1 GC (가비지 우선 Garbage First Collector)
- JDK9 : PS + ParallelOld 를 밀어내고 서버모드용 기본 컬렉터가 되미.
- JDK10 : GC 인터페이스를 도입하여 관심사분리
- JDK 14 : CMS가 F/O

- G1의 목표는 정지시간 예측 모델
- 기존 GC와의 차이 : 크기와 수가 고정된 세대 단위 영역 구분에서 벗어나, 연속된 자바 힙을 동일 크기의 여러 독립 리전으로 나누고, 이 리전중 이득이 큰 영역을 회수영역으로 고른다.
- G1이 해결해야했던 문제
    1. 리전간 참조문제 : 기억집합을 도입하여 참조문제를 해결하지만, 양방향 테이블이 필요햐여 기존 GC보다 메모리를 많이 사용한다.
    2. 재표시 단계 : 시작단계 스냅샷 알고리즘을 사용 (CMS는 증분 업데이트 알고리즘)
    3. 신뢰할 수 있는 정지 시간 예측 모델 : 감소평균 (최근의 평균적인 상태를 더 정확하게 알 수 있음)을 사용.

- 과정
    1. 최초 표시 (mark) : 아주 빠르게 정지. GC 루트 마크, TAMS 포인터의값 수정(= 새로운 객체는 가용리전에 할당되며, 이는 시작 스냅샷 생성과 동일한 효과)
    2. 동시 표시 (mark) : 사용자 스레드와 동시 동작. 객체 탐색
    3. 재표시 (mark) : 매우빠르게 정지함. 시작단계 스냅샷이후 변경된 소수의 객체만 처리. 
    4. 복사 및 청소 (copy, sweep) : 리전을 회수가치와 비용에 따라 줄세우고, 목표한 일시정지 시간에 부합하도록 회수 계획을 세운다. 
        - 리전에서 살아남은 객체들은 빈 리전에 이주시키는데, 이때 일시 중지되어야한다.
        - G1의 최우선 목표가 짧은 지연시간이 아닌 예측가능성 이므로, 일시정지하여 회수 효율을 극대화 하는 방향으로 구현되어있다.
- 기본 목표 정지시간은 200ms (일반적으로 100~300ms 가 적정)
- 정지시간이 매우 짧다면, 그 여파로 회수 속도가 새로 할당되는 속도를 따라잡지 못하여 쓰레기가 쌓여갈것이고, 종국에는 Full GC가 발생할것.

### 3.5.8 오늘날의 GC
- 그림 3-14 참고
- 신세대용과 구세대용의 구분이 사라졌다는 특징.






