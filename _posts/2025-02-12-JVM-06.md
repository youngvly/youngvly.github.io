---
title: "JVM 밑바닥까지 파헤치기 : 6 클래스 파일 구조"
date: 2025-03-12 22:00:00 +0900
categories: study, jvm, java
tags: study, java, jvm
---

# 6. 클래스 파일 구조
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
00000000    CA  FE  BA  BE  00  00  00  3D  00  13  0A  00  02  00  03  07  ...  
```

### 1. 매직넘버와 클래스 파일의 버전
#### 매직넘버
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
00000000    CA  FE  BA  BE  
```
`u4 magic`
- 가상머신이 허용하는 클래스 파일인지 여부를 빠르게 확인하는 용도. 
- 확장자와 달리 수정불가해서 안정적.
- .class 파일의 매직넘버는 0xCAFEBABE

#### 클래스 파일 버전
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
00000000    --  --  --  --  00  00  00  3D
## 십진수                      0   0   0  61
```

- 04 05가 minor version : 0
    - `u2 minor_version`
    - JDK 1.2 부터는 minor version을 사용하지않아 모두 0, 
    - 테스트 기능사용 버전인 경우 65535로 지정됨.
- 06 07이 major version : 61
    - `u2 major_version`
    - JDK 1.1 버전 = 45, 1씩 추가되며 61은 JDK 17

### 2. 상수풀
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
00000000    --  --  --  --  --  --  --  --  00  13
## 십진수                                      0  19
```
1. 상수풀 항목의 갯수 `u2 constant_pool_count`
    - 값 0 : 상수풀 항목을 참조하지 않음
    - 카운트는 1부터 시작함. 여기서는 상수 18개 존재
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
00000000    --  --  --  --  --  --  --  --  --  --  0A  00  02  00  03
## 십진수                                             10   0   2   0   3 
```
2. 상수풀 테이블 컬렉션 `cp_info constant_pool[constant_pool_count-1]`
    - 상수풀 안의 상수 각각이 모두 테이블이다.
    - JDK 21 기준으로 17가지의 상수타입이 존재하며, 모두 구조가 다르다.
    - 첫번째 상수 : 0A ~ 0E 상수
        - 0A : `u1 tag` :flag bit, 10=CONSTANT_Methodref_info = 같은 클래스의 메서드를 가리키는 심벌.
        - 0B 0C : `u2 index` 2 = 두번째 상수도 확인해봐야한다.
        - 0D 0E : `u3 index` 3 = 세번째 상수도 확인해봐야한다.
    ```sh
    Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
    00000000    --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  07
    00000010    00  04
    ## 십진수      0   4                                                       7
    ```
    - 두번째 상수 : 0F ~ 01 상수
        - 0F : `u1 tag` :flag bit, 7=CONSTANT_Class_info = 클래스나 인터페이스를 가리키는 심벌 참조.
        - 00 01 : `u2 name_index` : 4 = 네번째 상수에 클래스 이름을 알 수 있다.
    - 세번째 상수 : 02 ~ ... 상수 위와 동일한 방식으로 해석.

- 자바 클래스 이름의 길이가 결국 `u2 length` 가 표현할 수 있는 길이로 한정된다. = 65535 = 영문자 65535자
    - = 변수나 메서드 이름의 길이가 64KB를 넘으면 컴파일되지 않는다.


### javap
class 파일의 바이트코드 분석 도구.
```sh
$ {JAVA_HOME}/bin/javap -verbose TestClass
```
- 결과중에 소스코드에서는 없던 Utf8 상수가 있는데, (`I`,`()V`,`<init>`..) 이것들은 컴파일러가 자동 생성한 것으로 메서드의 반환값, 매개변수 갯수, 타입 등을 설명하는데 사용된다.

### 3. 접근 플래그 (access_flag)
- 상수 풀 다음 2byte
- 현재 클래스의 접근 정보를 식별하는 플래그.
- public, final, interface, abstract, enum, module,, 여부 등
```java
public class TestClass {}
```
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
000000B0    --  00  21
```
- 0x0021 = 0x0001 | 0x0020 = ACC_PUBLIC & ACC_SUPER
    - ACC_PUBLIC 0x0001 = true : public type
    - ACC_FINAL 0x0010 = false : final X
    - ACC_SUPER 0x0020 = true : JDK1.2 이상 사용. 

### 4. 클래스 인덱스(this_class), 부모 클래스 인덱스(super_class), 인터페이스 인덱스 컬렉션(interfaces)
#### 클래스 인덱스
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
000000B0    --  --  --  00  08 
```
- 현재 클래스의 완전한 이름을 결정
- 8번째 상수가 클래스 이름을 가지고 있다. (CONSTANT_Class_info)

#### 부모 클래스 인덱스
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
000000B0    --  --  --  --  --  00  02 
```
- java.lang.Object를 제외한 모든 자바 클래스는 부모클래스 인덱스값이 0이 아니다.
- 부모 클래스의 완전한 이름을 결정.
- 2번째 상수가 부모클래스 정보를 가지고 있다. (CONSTANT_Class_info)

#### 인터페이스 인덱스 컬렉션
```sh
Offset(h)   00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  Decoded text
000000B0    --  --  --  --  --  --  --  00  00 
```
- `u2 length` 컬렉션 사이즈 = 0 = 구현중인 인터페이스가 없다.
- 인터페이스가 있었으면 그 뒤로 주소 상수 인덱스가 나왔을 것.

### 5. 필드 테이블 (field_info)
- 자바언어에서 필드는 지역변수를 포함하지 않는다. 클래스 필드, 인스턴스 변수를 지칭.
- `u2 access_flags` : class의 access_flag와 유사.
- `u2 name_index` : 이름 상수 포인터
- `u2 descriptor_index` : 필드 및 메서드 서술자를 참조.
    - 서술자 : 완전한 이름 상수와 달리, 필드의 데이터 타입, 매개변수 목록, 반환값 등까지 기술함.
    - 서술자 식별문자 : p.307 표 6-6 참고
        - void inc() -> V() = void 리턴 메서드
        - int indexOf(char[] source, int index) -> `([CI)I`
- `u2 attribute_count` : 필드 갯수, 0 이면 값 선언이 되지않은 필드.
- `attribute_info   attributes[attribute_count]` : 필드 요소.

#### 그외
1. 상속받은 필드는 필드 테이블에 나열하지 않는다.
2. innerClass 인 경우, 코드엔 없는 외부 클래스 포인터 필드가 추가된다.
3. 자바 언어에서는 동일 필드명을 한 클래스안에 선언할 수 없는데,(overloading) 클래스파일 형식에서는 서술자만 다르면 다른 필드로 취급된다.

### 6. 메서드 테이블
- 필드테이블과 동일한 구조.
- 메서드 본문 코드는 `attribute_info` 의 `Code` 속성에 byteCode로 저장된다.
- 필드와 마찬가지로 이름,매개변수가 같고 반환값이 다른 메서드 오버라이딩이 클래스파일에서는 서술자가 다르므로 허용된다.

### 7. 속성 테이블(attribute_info)
- 자체 제작 컴파일러가 새로운 속성 유형을 정의할수있어 자유도가 있다.
- `u2 attribute_name_index` : attribute 이름 상수 포인터. 사전 정의된 속성 내에서 정해짐.
    - Code : 자바 코드가 컴파일된 결과인 바이트 코드 명령어들.
- `u4 attribute_length` : 속성 컬렉션 길이
- `u1 info[attribute_length]` : 속성 값 자체의 구조는 사용자가 정의할 수 있다. 

