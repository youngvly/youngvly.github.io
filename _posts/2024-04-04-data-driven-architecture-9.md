---
title: "데이터 중심 아키텍처 : 9. 일관성"
date: 2024-04-04 21:00:00 +0400
categories: study, architecture, db
tags: study, architecture, db
---
 # 09.
## 일관성 보장
- 최종적 일관성(수렴) : 복제 DB는 대부분 제공, 쓰기를 멈추고 불특정 시간을 기다리면 결국 모든 노드의 읽기 요청이 같은 값을 반환한다.
## 선형성 ( = 원자적 일관성 )
- 시스템에 데이터 복사본은 하나만 있다.
- 선형성 시스템에서는 x값이 원자적으로 바뀌는 시점이 있다고 가정하고, 쓰기요청 실행중에 한번 읽기요청에서 a를 반환했다면, 이후 읽기요청에서는 모두 동일한 a 값을 반환해야한다.
### 선형성대 직렬성
- 직렬성 : 여러객체를 읽고 쓰는 상황, 트랜잭션이 어떤 순서에 따라 실행되는것처럼 동작하도록 보장.
- 선형성 : 단일 객체를 읽고 쓰는 상황에서 최신성 보장.
### 선형성이 중요하게 요구되는 영역
1. 잠금과 리더 선출
  - zookeeper, apache curator,  oracle real application cluster
2. 제약 조건과 유일성 보장
  - 은행 계좌 잔고는 음수가 되면 안된다.
  - 영화 좌석은 1명만 예매할 수 있다.
3. 채널간 타이밍 의존성
  - A 저장 -> 후처리 발송 -> 후처리에서 A 조회
  - A 저장 -----------------------------> A 저장, 복제 완료
  - 위 케이스에서 후처리에서 A 조회에 실패하는 케이스. 부가적인 통신채널 (후처리 발송)을 제어해야한다.
### 선형성 시스템 구현하기
- 단일리더 복제 : 동기식 갱신된 팔로워는 선형적일 가능성이 있다.
- 합의 알고리즘 : 단일리더 복제에서 스플리 브레인(다중리더가 되거나), 복제본이 뒤처지는 문제를 막을 수단이 포함되므로 선형적.
- 다중 리더 복제 : 단일복사본만 존재하는게 아니라 비선형적.
- 리더 없는 복제 : 정족수로 일관성 달성할수있다고 하지만, 최종 쓰기 승리 충돌해소 방법은 시계skew때문에 비선형적이다. (p.332 9-6 그림 참고)
### 선형성과 정족수
- 읽기시에 읽기반환전에 읽기복구 동기식 수행 (읽기노드에서 최신값확인하여 구노드 업데이트) , 쓰기는 쓰기전에 최신상태를 읽음으로써 선형적으로 만들수는 있다.
## 선형성의 비용
- 단일리더복제를 사용하는, 다중 데이터센터 DB에서, 데이터센터간의 네트워크가 끊기면, 선형성과 가용성 사이에서 선택해야한다. (리더가 없는 데이터센터에서는 업데이트가 안되는 상황이므로, 선형성을 보장하려면 읽기기능도 중단해야함.)
### CAP 정리
: 위의 예처럼, 선형성이 필요없는 애플리케이션은 네트워크 문제에 더 강인하다.
: 원래는 일관성(Consistency/=선형성), 가용성(Availability), 분단 내성(Partition tolerance) 세개중 두개를 고르라는 것으로 표현되지만, 네트워크 문제처럼 분단 내성은 선택할수있는것이 아니기때문에 이 의미로는 사용하지 않는다.
### 선형성과 네트워크 지연
- 선형성은 느리므로, 현실적으로 많이 사용되지 않는다.

## 순서화 보장
- 시스템이 인과성에 의해 부과된 순서를 지키면, 그 시스템은 인과적으로 일관적이라고 한다.
- 인과적 순서가 전체 순서는 아니다.
  - 선형성 시스템에서는 인과성이 연산의 전체 순서를 정할 수 있다. 
  - 두 연산중, 순서를 정할 수 없다면 비교할 수 없으므로, 인과성이 부분순서를 정의한다.
- 선형성은 인과적 일관성을 내포한다. = 선형적이라면 인과성을 보장한다.
- 비선형 시스템이 인과적 일관성을 유지하려면
  - 연산의 순서를 알아야한다 = DB는 애플리케이션이 데이터의 어떤 버전을 읽어서 쓰기요청이 오는지 알아야한다.
### 일련번호 순서화
- 타임스탬프, 카운터등의 단조증가 일련번호를 할당하고, 팔로워에서도 일련번호순으로 처리되게하면 언제나 인과성에 일관적이다.
- 비 인과적 일련번호 생성기 : 다중리더일때 타임스탬프,id범위선점 등으로 일련번호를 할당하면 비 인과적이다.
- 램포트 타임스탬프 (카운터, 노드id): 카운터가 큰것이 더 최신, 노드 id가 더 큰것이 더 최신.
  - 멀티 노드에서 인과성에 일관적이다. (p.343 그림 9-8)
### 전체 순서 브로드캐스트
- 전체 노드에서 유일성 보장이 되어야한다면, 램포트 타임스탬프로는 유일성을 보장할 수 없다.
- ex) 주키퍼
- 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기 : 전체 순서 브로드캐스트를 추가 전용 로그로 사용하여 선형성 compare-and-set dustks rngus.
- 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기 : 선형성 저장소의 increment-and-get 연산을 사용하여 메세지에 일련번호를 붙여 순서를 보장.

## 분산 트랜잭션과 합의
### 원자적 커밋과 2단계 커밋(2PC)
- 원자성은 보조색인이 주 데이터와 일관성을 유지하도록 보장한다. 
- 단일 노드에서 분산 원자적 커밋으로 : 
- 2단계 커밋 : 애플리케이션 라이브러리 레벨의 코디네이터를 사용하여, 각 쓰기 -> (db노드에 커밋 준비요청 -> 커밋 ) 단계를 거친다.
  - 코디네이터가 트랜잭션 id를 부여한다. 
  - 커밋 준비요청에서 동의한 노드는, 중간에 죽더라도 다시 살아나면 커밋해야한다.
  - 코디네이터가 준비요청 후 커밋단계에서 죽으면, 노드들은 불안정 상태에서 복구될때까지 기다려야한다.
- 3단계 커밋
  - 2단계 커밋에서, 각 노드가 타임아웃을 들고있는것. 원자성을 보장하지못하므로 잘 사용되지않음.

### 현실의 분산 트랜잭션
- XA
- 잠금을 가지고있기때문에, 트랜잭션이 장애상태인것을 인지해야한다.

### 내결함성을 지닌 합의
- 대부분의 합의구현은 과반수 노드에 장애가 나더라도 안전성 속성(동의,무결성,유효성)을 항상 만족한다.
  - 균일한 동의 : 어떤 두 노드도 다르게 결정하지 않는다
  - 무결성 : 어떤 노드도 두번 결정하지 않는다.
  - 유효성 : 한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것이다.
  - 종료 : 죽지 않는 모든 노드는 결국 어떤 값을 결정한다.
- 전체 순서 브로드캐스트는 합의를 여러번 반복하는것과 동일하다.
  - 합의의 동의 속성때문에 모든 노드는 같은 메세지를 같은 순서로 전달하도록 결정한다.
- 에포크 번호 붙이기와 정족수
  - 각 에포크 내에서는 리더가 유일하다고 보장한다.
  - 에포크간 리더중 충돌이 있으면 에포크 번호가 큰 리더가 이긴다.
  - 