---
title: "TDD 3장 테스트주도 개발의 패턴"
date: 2023-01-30 19:10:00 +0400
categories: test
tags: test, tdd
---

# 25. 테스트주도 개발 패턴
### 격리된 테스트
- 테스트들은 실행순서와 결과 등에 서로 독립적이어야한다.
### 테스트 목록
- 할일 목록을 나열하고 우선순위를 정하라. 할일 목록을 한번에 테스트로 구현하는것은, 나중에 리팩토링에 관성을 가지게되어 걸림돌이 될 수 있고, 전체 테스트가 통과하게 하기까지 많은 시간이 소요되므로, 하나씩 정복하는것이 좋을것이다.
### 테스트를 먼저 작성
- 테스트의 대상이 되는 코드를 작성하기 전에 테스트를 먼저 작성하는것이 좋다.
- 테스트는 프로그램 설계와 작업 범위 조절에 유용하다. 
### assert 우선
- assert를 먼저 작성하면 작업을 단순하게 만들 수 있다.  => 결과를 얻기위해 필요한것들을 역으로 유추하는 방식.
### 테스트 데이터
- 데이터 간의 차이가 있다면 그 속에 의미가 있어야한다. 1과 2사이에 개념적 차이가 없다면 1을 사용하자.
- 테스트 데이터에 대한 대안은, 실제 세상에서 얻어진 실제 데이터를 사용하는것.
### 명백한 데이터
- 테스트 자체에 예상되는 값과 실제값을 포함하여 둘사이의 관계를 드러내야한다.
- 기호상수가 이미 있다면 사용하라.
```java
  // asis
  assertEquals(4.95 result);
  // tobe
  assertEquals(100 / 2 * (1 - 0.015), result)
```
> 단위테스트였나, 결과값은 테스트안에서 계산되지않고, 값으로 비교되어야한다고 본것같은데,, 사실 구현내용과 동일한 계산로직을 테스트 결과값에서도 동일하게 사용된다면 의미있는 테스트가 아닐것같다. 

# 26. 빨간 막대 패턴
### 한단계 테스트
- 목록중에서 다음 테스트를 선정할때, 구현할 수 있다고 확신이 드는것을 선정하라. (아는것에서 모르는것으로 구현하여 성장하라.)
### 시작 테스트
- 간단한 오퍼레이션부터 테스트를 시작하라.
  - 출력이 입력과 같은경우?
### 설명 테스트
- 테스트로 설명을 요청하고 설명하라.
### 학습 테스트
- 외부 라이브러리를 학습하기위해 테스트를 작성해볼 수 있다.
### 또 다른 테스트
- 회의중에 주제에서 벗어나지 않으려면, 주제와 벗어나는 아이디어가 떠올랐을때 테스트를 할일 목록에 적고 다시 주제로 돌아오자.
### 회귀(regression) 테스트
- 장애가 발생했을때, 장애로 인하여 실패하고 복구시 통과될수있는 테스트를 작성하라.
- 전체 애플리케이션 차원에서 테스트를 수행하는것도 가치가있다.
### 휴식
- 피로는 판단력에 음성적인 영향을 끼치고, 판단력은 다시 피로에 음성적인 영향을 끼친다.
- 휴식 주기를 알아차리기위한 방식
  - 물병을 비우면 휴식하자
  - 정규 근무시간 후의 약속이 진행을 멈추는데에 도움이 될 수 있다.
  - 주단위로는 주말활동
  - 년단위로는 강제 휴가정책 회복1주~복귀1주 => 최소 3주~4주
### 다시하기
- 코드가 뒤죽박죽이되어 갈길을 잃었을땐, 다지우고 처음부터
### 싸구려책상 좋은 의자

# 27. 테스팅 패턴
### 자식 테스트
- 큰 테스트케이스를 돌아가게하려면, 깨지는 부분을 작은 테스트로 분리하고, 성공하면 큰테스트를 추가하라.
- 왜 큰 테스트가 나올수밖에 없었는지 돌아보자. 작게 여러개로 쪼갤 수 있다면 큰 테스트를 삭제하자.
### 모의 객체 (Mock object)
- 테스트할때 db는 의존성이 높기때문에, mock db를 사용할 수 있다.
- mock object는 테스트안에 기대결과값을 확인할수있어 가독성이 높다.
### self shunt = loop back
- 한 객체가 다른 객체와 올바르게 대화하는지 테스트하기위해, 테스트 대상 객체를 테스트 클래스로 만들면된다.
- 테스트 대상 클래스의 인터페이스 추출이 필요하다. 클래스를 블랙박스 테스트하는것이 좋은지, 인터페이스 추출이 쉬운지는 판단이 필요.
```python
  # test target interface
  class ResultListener :
      def __init__(self) :
        self.count = 0
      def startTest(self)

  # test class
  class ResultListenerTest(ResultListener) :
    # TestResult 와 listener 간의 통신을 테스트
    def testNotification(self) :
      self.count = 0
      result = TestResult()
      result.addListener(self)    # listener 객체를 따로 만들지않고, 테스트케이스가 listener가 되어 테스트한다.

      WasRun("testMethod").run(result)

      assert 1 == self.count
    

    def startTest(self):
      self.count += 1
```
### 로그 문자열
- 오퍼레이션의 호출순서등을 확인하기위해 문자열에 순차적으로 저장하는 로그 문자열을 사용할 수 있다. `assert("setUp testMethod tearDown" == result.log)`
- 자바에서는 `List<String>` 이 낫겠다.
### 크래시 테스트 더미
- 재연하기힘든 에러상황을 테스트해야한다면, 재연 상황을 구현하는 대신 그냥 예외를 발생시키는 객체를 만들면 된다. (override)
```java
  public void testFileSystemError(){
    File f = new File("foo"){
        @Override
        public boolean createNewFile() throws IOException {
          throw new IOException();
        }
      } 
    }

    assertThrow(() -> saveAs(f), IOException.class)
  }
```
### 깨진 테스트
- 혼자서 프로그래밍할때 프로그래밍 세션을 끝마칠때는 테스트가 깨진 상태로 끝마치는것이 좋다.
- 나중에 돌아왔을때 어느 작업부터 시작할 것인지 명백히 알 수 있다.

### 깨끗한 체크인
- 팀 프로그래밍을 할때 프로그래밍 세션을 끝마칠때는 모든 테스트가 성공한 상태로 끝마치는것이 좋다.
- 팀원들이 코드를 체크인하기전에, 모든 테스트가 돌아간다는것이 보장되어야한다.
- 실패한 테스트는 방금 본인이 짠 프로그램을 완벽히 이해하지 못한다는 뜻이다. 깨지면 다 날리고 다시하는것도 방법이다.