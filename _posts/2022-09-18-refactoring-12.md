---
layout: post
title: "Refactoring 12 상속 다루기"
date: 2022-09-18 23:51
categories: Refactoring study
tags: cleanCode, study
---
# 12 상속 다루기
## 12.1 [메서드 올리기](https://refactoring.com/catalog/pullUpMethod.html)
- 메서드들의 본문 코드가 같을때
- 메서드에서 서브클래스의 필드를 사용할때, 필드부터 올려야한다.
### 절차
1. 똑같이 동작하는 메서드인지 살핀다. 하는일은같지만 코드가 다르다면 리팩토링부터
2. 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인.
3. 메서드 시그니처를 함수선언 바꾸기(6.5)로 통일한다.
4. 슈퍼클래스에 메서드 생성후 본문 복붙
5. 정적검사 수행
6. 서브클래스 중 하나의 메서드 학제
7. 테스트 6,7 반복

## 12.2 [필드 올리기](https://refactoring.com/catalog/pullUpMethod.html)
- 필드들이 비슷한 방식으로 쓰인다고 판단되면 슈퍼클래스로 끌어올리자
- 서브클래스에서 필드에 접근할 수 있어야하므로 protected로 선언
- 메서드까지 올릴 수 있다면 12.1 진행

## 12.3 [생성자 본문 올리기](https://refactoring.com/catalog/pullUpConstructorBody.html)
- 공통로직을 super(..)로 대체한다.
- 공통로직이 초기화 나중에 나온다면, 메서드로 분리하여 메서드를 superClass에 둔다.

## 12.4 [메서드 내리기](https://refactoring.com/catalog/pushDownMethod.html)
- 슈퍼클래스의 메서드를 사용하는 서브클래스가 정확히 무엇인지를 호출자가 알고있을때만 적용할 수 있다.
- 사용처하는 서브클래스를 모른다면 다형성으로 바꿔야한다.

## 12.5 [필드 내리기](https://refactoring.com/catalog/pushDownField.html)
- 특정 서브클래스에서만 사용하는 필드는 서브클래스로 옮긴다.

## 12.6 [타입코드를 서브클래스로 바꾸기](https://refactoring.com/catalog/replaceTypeCodeWithSubclasses.html)

- 특정타입에서만 의미있는 값을 사용하는 필드나 메서드가 있을때
- 다형성 사용가능
1. 직접 상속 방식
    - 
2. 간접 상속 방식 : 유형을 클래스로 분리.
   - ex) 타입을 단순 string이 아닌 enum으로?
   - 유형클래스를 다른 용도로 쓰고싶을때.
   - 유형이 유동적일때는 직접보다는 간접으로.

## 12.7 [서브클래스 제거하기](https://refactoring.com/catalog/removeSubclass.html)
- 서브클래스의 역할이 작거나 의미없을때
 
### 절차
1. 서브클래스 생성을 슈퍼클래스의 팩터리함수에 넣는다.
2. 서브클래스 타입을 검사하는 코드가 있다면 (instanceOf) 함수 추출하여 슈퍼클래스로 옮긴다.
3. 서브클래스 타입을 슈퍼클래스 필드로 만든다.
4. 서브클래스를 참조하는 메서드가 방금 만든 타입 필드를 이용하도록 수정한다.
5. 서브클래스를 지운다.

## 12.8 [슈퍼클래스 추출하기](https://refactoring.com/catalog/extractSuperclass.html)
### 절차
1. 빈 슈퍼클래스를 만들고, 상속하도록 한다.
2. 생성자 본문올리기(12.3) 메서드올리기(12.1) 필드올리기(12.2) 차례로 적용하여 슈퍼클래스로 옮긴다.
3. 서브클래스에 남은 메서드들을 검토하고 공통되는부분을 메서드올리기로 정리한다.
4. 원래 클래스들을 사용하는 코드를 검토하여 슈퍼클래스의 인터페이스를 사용하게할지 고민한다.

## 12.9 [계층 합치기](https://refactoring.com/catalog/collapseHierarchy.html)
- 서브 클래스와  슈퍼클래스가 비슷해져서 독립적으로 존재할 의미가 사라진다면
> 12.7과 차이는?
### 절차
1. 두 클래스중 제거할 것을 고른다 (더 적합한 이름의 클래스로 남기자)
2. 필드올리기, 메서드올리기, 필드내리기, 메서드내리기 등 적용하여 하나의 클래스로 합친다.
3. 제거할 클래스를 참조하던 모든 코드가 남겨질 클래스를 참조하도록 고친다.
4. 빈클래스 제거

## 12.10 [서브클래스를 위임으로 바꾸기](https://refactoring.com/catalog/replaceSubclassWithDelegate.html)
- 상속의 단점
    - 분기 조건이 여러개여도 하나의 조건만 선택해 서브클래싱할 수밖에 없다.
    - ex) 나이대 , 소득기준 두가지로 서브클래싱하려면 둘중하나를 선택하여 젊은이,어르신 / 부자,서민으로 분리
    - 자식들이 슈퍼클래스를 어떻게상속해 쓰는지 이해해야한다. 
- 위임은 위 두문제를 해결해줄 수 있다.
    - 결합도가 훨씬 약하다.
    - **처음에는 상속으로 접근하고 나중에 위임으로 바꿔도 늦지않다**
- **상속이 괜찮을때** : 서브클래스에 대한 지식 없이도 기반 클래스를 이해할 수 있을때
- **위임이 필요할때** : 서브클래스 유형이 동적으로 전환이 필요할때.
### 절차
1. 생성자를 호출하는 곳이 많다면 생성자를 팩터리함수로 바꾼다.
2. 위임으로 사용할 빈 클래스를 만든다. 슈퍼클래스를 가리키는 역참조도 필요하다.
3. 위임을 저장할 필드를 슈퍼클래스에 추가한다.
4. 1의 팩토리 함수를 수정하여 위임 인스턴스를 생성하고 위임 필드를 초기화한다.
5. 서브클래스의 메서드중 일부를 위임클래스로 이동한다. 서브클래스에서는 위임클래스 메서드를 호출.
6. 서브클래스 외부에도 원래 메서드를 호출하는 코드가 있다면 서브클래스의 위임코드를 슈퍼클래스로옮긴다. 위임이 존재하는지를 검사하는 보호코드로 감싸야한다. 호출하는 외부코드가 없다면 원래 메서드는 죽은 코드가 되므로 제거한다.
7. 서브클래스 생성자 호출부를 슈퍼클래스 생성자로 바꾼다.
8. 서브클래스 삭제

 > 1. 서브클래스가 하나일때의 예시에서 생성자에 슈퍼클래스 역참조를 위해 슈퍼클래스를 필드로 저장하는데, 필드로 들고있는게 맞는가,, 참조이니까 동작은 상관없을것같긴한데 불변 객체로 메서드 에서 넘겨주는게 확실하지않나?.?
 
 - 서브클래스가 여러개일때,서브클래스들 각각을 위임하거나, 서브클래스를 묶는 슈퍼클래스를 위임한다.
    - 슈퍼클래스를 위임할때, 기존 슈퍼클래스보다 목적이 줄어든 슈퍼클래스로 분리될 수 있다.
  
> 개인적으로 java에서 계층은 interface로만 사용하고, 상속보다는 위임을 선호하는듯.

## 12.11 [슈퍼클래스를 위임으로 바꾸기](https://refactoring.com/catalog/replaceSuperclassWithDelegate.html)
- ex) 자바의 [stack 클래스](https://docs.oracle.com/javase/7/docs/api/java/util/Stack.html)
    - list의 연산이 stack에서 필요없지만, 인터페이스가 노출되게 된다.
- 슈퍼클래스의 기능들이 어울리지 않는다면 상속을 사용하면 안되는것.
- 슈퍼클래스가 사용되는 모든 곳에서 서브클래스의 인스턴스를 대신 사용해도 이상없이 동작해야한다.
- 위임을 이용하면 기능 일부만 빌려오는 별개의 개념임이 명확해진다.
- 
 