---
title: "데이터 중심 아키텍처 : 8.분산 시스템의 골칫거리"
date: 2024-01-03 16:00:00 +0400
categories: study, architecture, db
tags: study, architecture, db
---

# 08. 분산 시스템의 골칫거리
- 분산 시스템 : 비공유 시스템, 네트워크로만 연결된 다수의 장비
## 클라우드 컴퓨팅과 슈퍼컴퓨팅
- 분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고, 소프트웨어에 내결함성 메커니즘을 넣어야한다.
- 결함처리는 소프트웨어 설계의 일부이어야하며, 소프트웨어 운영자로써 결함이 발생하면 소프트웨어가 어떻게 동작할지 알아야한다.
## 신뢰성 없는 네트워크
- 다른 노드로 요청을 보내서 응답을 받지 못했다면, 그 이유를 아는것은 불가능하다.
    - ex) 요청이 손실되었는지, 원격노드가 다운되어 도달하지 못했는지, 응답이 손실되었는지 등.
    - 일반적으로 타임아웃이 이 문제를 다루는 방법
## 현실의 네트워크 결함
- 네트워크 결함(분단,분리) : 네트워크의 일부가 다른쪽과 차단되는것.
- 소프트웨어가 네트워크 문제에 어떻게 반응하는지 알고 시스템이 그로부터 복구할수있도록 보장해야한다. > 카오스몽키의 기반이되는 생각
## 결함 감지
- TCP ACK만으로 요청의 성공을 확신하지 말고, 애플리케이션 수준에서 긍정 응답을 받아야한다.
- 원격노드가 다운되고있다는 빠른 피드백은 유용하지만, 의존할 수 없으므로 타임아웃으로 관리할 수 있다.
> 일시적 타임아웃으로 복구될 수 있는 연결이 끊어지는 상황이 있었고 재발 방지로 타임아웃을 무제한급으로 늘리려했던적이있는데, 당연하겠지만 타임아웃의 취지를 다시 생각해보고 적절한 값을 찾는게 좋겠다.
## 타임아웃과 기약없는 지연
- 이미 높은 부하가 주어진 상황이라면 타임아웃이 짧은경우, 죽었다고 판단된 노드의 부하를 다른 노드가 추가로 받아야해서 악순환이 될 수 있다.
- 네트워크 왕복시간의 분포를 측정하여, 적절한 트레이드 오프가 필요.
- 동적 타임아웃 솔루션도 있음. 파이증가 장애감지기 (Akka와 Casnadra가 사용중)
+ 네트워크 혼잡과 큐 대기 : 트래픽 증가 -> 큐 지연 -> TCP타임아웃으로 재전송, 트래픽 더증가 ..
## 동기 네트워크 vs 비동기 네트워크
- 동기식 : 전화통화, 회선이 만들어져서 대역폭이 할당된다. 
    - bounded delay : 큐 대기문제가 없어 종간 지연시간의 최대치가 고정값이다. 
- 비동기식 : TCP, 패킷 교환 프로토콜. 가용한 네트워크 대역폭을 기회주의적으로 사용한다.
    - 왜 패킷교환을 사용할까? 순간적으로 몰리는 트래픽에 최적화되어있기 때문.
        - 회선을 쓰면 대역폭 할당을 추정해야하는데, 추정치가 높으면 낭비, 낮으면 전송이 느려지므로 순간적으로 몰리는 데이터 전송에 적합하지 않다.
- 회선 + 패킷교환을 시도한 ATM(Asynchronous Transfer Mode ,은행아님)도 있다. 우선순위 패킷, 전송측에서 전송률 제한을 잘 사용하면됨.
## 신뢰성 없는 시계
- NTP : Network TIme Protocol : 서버그룹에서 보고한 시간에 따라 컴퓨터 시계 조정
    - NTP 클라이언트는 여러 서버에 질의를 보내고, 큰차이가 있는것들은 무시한다.
 > 서버 시간을 알려주는 사이트들은 어떤 기준으로 가져오는건가?
### 단조시계 vs 일 기준 시계
- 일 기준 시계 ( time of day clock)
    - epoch 이래로 흐른 시간, NTP로 보통 동기화 하기때문에 시간이 계속 과거로 오는것처럼 보일수도 있다. 이런 이유로 경과시간 측정에는 적합하지 않다.
    - System.currentTImeMillis()
-  단조 시계 (monotonic clock)
    - 한방향으로만 흐르며, 경과시간 측정에 적합하다.
    - System.nanoTime()
### 시계 동기화와 정확도
- 컴퓨터의 수정시계는 (일기준) drift 현상이 생긴다. (더빠르거나 더 느린)
- NTP로 시계를 동기화하며, 동기화 간격이 길수록 오차가 커질 수 있다.
### 동기화된 시계에 의존하기
- SW가 동기화된 시계에 의존하면, 극적인 고장보다는 조용하고 미묘한 데이터 손실이 발생할 가능성이 높다.
- 다른 노드와 시계가 많이 차이나는 노드는 클러스터에서 제거되어야한다.
### 이벤트 순서화용 타임스탬프
- 최종 쓰기 승리 (Last Write Wins) 중 ‘가장최근’ 의 기준은 로컬 일기준 시계에 의존하며, 이 시계는 틀릴 수 있다.   
- 논리적 시계, 카운터 기반은 이벤트 순서화의 안전한 대안이다. 상대적인 순서만 측정.
- 물리적 시계 : 일기준, 단조 시계
### 시계읽기는 신뢰구간이 있다.
- 원자(세슘)시계는 제조사에서 제공하는 예상 오류범위가 있다.
- 일기준 시계는 drift + NTP서버의 불확실성 + 네트워크 왕복시간
- spanner 의 trueTime API는 현재 시각의 가능한 범위를 알려준다.
### 전역 Snapshot용 동기화된 시계
- snapshot은 작고많은 트랜잭션과, 오래실행되는 읽기전용 트랜잭션을 분리하는데 유용.
- snapshot격리 구현중 transactionId (Auto increment)는 간단하지만, db가 클러스터링 되어있다면 어려울 수 있다.
- time을 transactionId로 사용한다면,노드간 시간차가 작아야하는데, 이때 스패너의 방법 : A와 B 노드의 타임스탬프를 조회하여 
    - `A최소 < A최대 < B최소 < B최대` 이면 A<B
    - 위 조건이 되는걸 보장하기위해 트랜잭션 커밋전에 시간의 신뢰구간 길이만큼 기다려야한다.

## 프로세스 중단
- 분산시스템에서 리더의 생사를 판단하는 방법중, 리더가 다른 노드들로부터 lease임차권을 얻고, 노드가 장애가나면 임차권 갱신이 멈춰지므로 다른 노드가 리더가 될 수 있다.
    - 이때 임차권 만료시각을 다른 노드에서 설정했는데, 로컬 시스템의 시계와 비교하는경우 시간차로인한 오류가 발생할 수 있다.
-   분산시스템의 노드는 어느 시점에 실행이 상당시간 멈출 수 있다고 가정해야한다.
> GC 에 특별히 대응하고있는것이 있는가?
### 응답 시간 보장
- 프로세스가 명시된 간격의 CPU 시간을 할당받을 수 있게 보장되도록 스케줄링해주는 실시간 운영체제 (RTOS) 가 필요하다.
- 엄격한 실시간 시스템 : 항공기,로켓,,, 소프트웨어가 응답해야하는 데드라인이 명시된다.
- 실시간 과 고성능은 다르다. 실시간 시스템은 처리량이 낮을 수 있다.
- 대부분의 데이터 처리 시스템은 비실시간 환경에서 운영될때 발생하는 중단과 시계 불안정으로부터 고통받을 수 밖에 없다.
### 가비지 컬렉션의 영향을 제한하기
- GC 발생직전을 탐지하여, 해당 노드를 서비스에서 제외하는 방식으로 응답시간을 안정화시킬 수있다. > 금융거래시스템
- 수명이 긴 객체의 전체 GC가 쌓이기 전에 주기적으로 프로세스를 재시작하는 방법도 있다.
## 지식,진실, 그리고 거짓말
### 진실은 다수결로 결정된다.
- 한개의 노드가 일시적으로 멈췄다하더라도, 다수의 노드가 정족수(투표)하여 노드를 방출시킬 수 있다.
### 리더와 잠금
- 노드의 과반수가 어떤 노드가 죽었다고 선언했음에도, 그 노드가 리더처럼 행동한다면 스플릿브레인등의 문제가 발생할 수 있다.
#### 펜싱토큰 (fencig token)
- 리더가 잠금을 획득할때 단조 증가하는 ID를 얻으며, 더 과거의 ID를 가진 요청은 무시된다.
## 비잔틴 결함
- 노드가 거짓말을 하는경우, (펜싱토큰 값을 조작하는경우) 비잔틴결함이라한다.
- 비잔틴 장군문제 : 신뢰할 수 없는 환경에서 합의에 도달하는 문제 (2/3이 동의하는지)
- 비잔틴 내결함성을 지닌다 : 악의적으로 네트워크방해, 노드오작동이 있어도 시스템이 올바르게 동작하는 경우.
- 대부분의 서버측 데이터 시스템에서 비잔틴 내결함성 솔루션을 배치하는것은 비용이 커서 실용적이지 않다. 
- 웹서비스는 노드들을 모두 같은 버전으로 배포하기때문에, 다수결도 불가능.
## 시스템 모델과 현실
- 시스템에서 발생할것으로 예상되는 결함의 종류. 
- 타이밍
    - 동기식 모델 : 네트워크 지연, 프로세스 중단, 시계오차 모두에 제한이있다고 가정.
    - 부분 동기식 모델 : 대부분 동기식이지만, 때땔 시계드리프트의 한계치를 초과한다. (현실적)
    - 비동기식 모델 : 타이밍에 대한 어떤 가정도 할 수 없다. 
- 노드 장애
    - crash-stop 결함 : 노드가 응답을멈추면 돌아오지않는다는 뜻 
    - crash-recovery 결함 : 멈춘 노드의 메모리는 손실되지만, 비휘발성 저장소가 있다고 가정. (현실적)
    - 비잔틴 결함 : 노드는 기만하는것을 포함하여 무슨 일이든 할 수 있다.
### 알고리즘의 정확성
- 알고리즘은 시스템 모델에서 발생하리라고 가정한 모든 상황에서 그 속성들을 항상 만족시키면 해당 시스템 모델에서 정확하다.
### 안전성과 활동성
- 안전성 : 나쁜일은 일어나지 않는다.
    - 펜싱토큰의 유일성과 단조일련번호
    - 분산 알고리즘은 네트워크장애, 노드가 모두 죽는 어떤 상황에서도 알고리즘은 잘못된 결과를 반환하지 않는다고 보장해야한다. (안전성 속성 만족)
- 활동성 : 좋은일은 결국 일어난다.  최종적 일관성.
    - 펜싱토큰 : 토큰을 요청하고 죽지않은 노드는 결국에는 응답을 받는다.
    - 분산 알고리즘에서, 노드 다수가 죽지않고 결국 복구되었을때 응답을 받아야한다.
### 시스템 모델을 현실세계에 대응시키기
- 안전성, 활동성과 시스템 모델은 분산시스템의 정확성을 따지는데 유용하다. 